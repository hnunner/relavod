qRow$c_prop + (qRow$c_prop * runif(1, -epsilon, epsilon))
qRow$c_prop + (qRow$c_prop * runif(1, -epsilon, epsilon))
qRow$c_prop + (qRow$c_prop * runif(1, -epsilon, epsilon))
qRow$c_prop + (qRow$c_prop * runif(1, -epsilon, epsilon))
qRow$c_prop + (qRow$c_prop * runif(1, -epsilon, epsilon))
qRow$c_prop + (qRow$c_prop * runif(1, -epsilon, epsilon))
qRow$c_prop + (qRow$c_prop * runif(1, -epsilon, epsilon))
qRow$c_prop + (qRow$c_prop * runif(1, -epsilon, epsilon))
qRow$c_prop + (qRow$c_prop * runif(1, -epsilon, epsilon))
qRow$c_prop + (qRow$c_prop * runif(1, -epsilon, epsilon))
qRow$c_prop + (qRow$c_prop * runif(1, -epsilon, epsilon))
qRow$c_prop + (qRow$c_prop * runif(1, -epsilon, epsilon))
source('~/git/uu/mscp-model/code/composition.R')
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
runif(1)
as.integer(runif(1) > 0.5)
as.integer(runif(1) > 0.5)
as.integer(runif(1) > 0.5)
as.integer(runif(1) > 0.5)
as.integer(runif(1) > 0.5)
as.integer(runif(1) > 0.5)
as.integer(runif(1) > 0.5)
as.integer(runif(1) > 0.5)
c_prop <- c()
for (i in 1:length(state)) {
c_prop <- c(c_prop, as.integer(runif(1) > 0.5))
}
state <- c("C1", "D1", "C2", "D2", "C3", "D3")
c_prop <- c()
for (i in 1:length(state)) {
c_prop <- c(c_prop, as.integer(runif(1) > 0.5))
}
state <- c("C1", "D1", "C2", "D2", "C3", "D3")
c_prop <- c()
for (i in 1:length(state)) {
c_prop <- c(c_prop, as.integer(runif(1) > 0.5))
}
state <- c("C1", "D1", "C2", "D2", "C3", "D3")
c_prop <- c()
d_prop <- c()
for (i in 1:length(state)) {
c_prop <- c(c_prop, as.integer(runif(1) > 0.5))
d_prop <- c(d_prop, as.integer(runif(1) > 0.5))
}
qTable <<- data.frame(state, c_prop, d_prop)
View(qTable)
c_avPayoff <- c(rep(0,length(state)))
state <- c("C1", "D1", "C2", "D2", "C3", "D3")
c_prop <- c()
d_prop <- c()
for (i in 1:length(state)) {
c_prop <- c(c_prop, as.integer(runif(1) > 0.5))
d_prop <- c(d_prop, as.integer(runif(1) > 0.5))
}
c_avPayoff <- c(rep(0,length(state)))
d_avPayoff <- c(rep(0,length(state)))
qTable <<- data.frame(state, c_prop, c_avPayoff,
d_prop, d_avPayoff)
View(qTable)
View(qTable)
currentState <<- state[1]
currentState <<- state[sample(1,1,length(state))]
currentState <<- state[sample(1,1,length(state))]
currentState <<- state[sample(1,1,length(state))]
currentState <<- state[sample(1,1,length(state))]
currentState <<- state[sample(1,1,length(state))]
sample(1,1,length(state))
sample(1,1,length(state))
sample(1,1,length(state))
sample(1,1,length(state))
sample(1,length(state))
sample(length(state),1)
sample(length(state),1)
sample(length(state),1)
sample(length(state),1)
sample(length(state),1)
sample(length(state),1)
sample(length(state),1)
sample(length(state),1)
sample(length(state),1)
currentState <<- state[sample(length(state),1)]
currentState <<- state[sample(length(state),1)]
currentState <<- state[sample(length(state),1)]
currentState <<- state[sample(length(state),1)]
currentState <<- state[sample(length(state),1)]
currentState <<- state[sample(length(state),1)]
currentState <<- state[sample(length(state),1)]
currentState <<- state[sample(length(state),1)]
currentState <<- state[sample(length(state),1)]
currentState <<- state[sample(length(state),1)]
currentState <<- state[sample(length(state),1)]
currentState <<- state[sample(length(state),1)]
currentState <<- state[sample(length(state),1)]
currentState <<- state[sample(length(state),1)]
currentState <<- state[sample(length(state),1)]
currentState <<- state[sample(length(state),1)]
currentState <<- state[sample(length(state),1)]
state <- c("C1", "D1", "C2", "D2", "C3", "D3")
c_prop <- c()
for (i in 1:length(state)) {
c_prop <- c(c_prop, as.integer(runif(1) > 0.5))
}
d_prop <- 1 - c_prop
state <- c("C1", "D1", "C2", "D2", "C3", "D3")
c_prop <- c()
for (i in 1:length(state)) {
c_prop <- c(c_prop, as.integer(runif(1) > 0.5))
}
d_prop <- 1 - c_prop
state <- c("C1", "D1", "C2", "D2", "C3", "D3")
c_prop <- c()
for (i in 1:length(state)) {
c_prop <- c(c_prop, as.integer(runif(1) > 0.5))
}
d_prop <- 1 - c_prop
c_avPayoff <- c(rep(0,length(state)))
d_avPayoff <- c(rep(0,length(state)))
qTable <<- data.frame(state, c_prop, c_avPayoff,
d_prop, d_avPayoff)
View(qTable)
qTable[qTable$state == currentState, ]
qTable[qTable$state == currentState, ]$c_prop
qTable[qTable$state == currentState, ]$c_prop
qTable[qTable$state == currentState, ]$c_prop
qTable[qTable$state == currentState, ]$c_prop
qTable[qTable$state == currentState, ]$c_prop
qTable[qTable$state == currentState, ]$c_prop
qTable[qTable$state == currentState, ]$c_prop
qTable[qTable$state == currentState, ]$c_prop
COOPERATE <<- 1
DEVIATE <<- 0
action <-
if (qTable[qTable$state == currentState, ]$c_prop == 1)
COOPERATE else DEVIATE
action <-
if (qTable[qTable$state == currentState, ]$c_prop == 1)
COOPERATE else DEVIATE
action <-
if (qTable[qTable$state == currentState, ]$c_prop == 1)
COOPERATE else DEVIATE
action <-
if (qTable[qTable$state == currentState, ]$c_prop == 1)
COOPERATE else DEVIATE
action <-
if (qTable[qTable$state == currentState, ]$c_prop == 1)
COOPERATE else DEVIATE
action <-
if (qTable[qTable$state == currentState, ]$c_prop == 1)
COOPERATE else DEVIATE
action <-
if (qTable[qTable$state == currentState, ]$c_prop == 1)
COOPERATE else DEVIATE
action <-
if (qTable[qTable$state == currentState, ]$c_prop == 1)
COOPERATE else DEVIATE
qTable
currentState <<- state[sample(length(state),1)]
action <-
if (qTable[qTable$state == currentState, ]$c_prop == 1)
COOPERATE else DEVIATE
action <-
if (qTable[qTable$state == currentState, ]$c_prop == 1)
COOPERATE else DEVIATE
action <-
if (qTable[qTable$state == currentState, ]$c_prop == 1)
COOPERATE else DEVIATE
action <-
if (qTable[qTable$state == currentState, ]$c_prop == 1)
COOPERATE else DEVIATE
action <-
if (qTable[qTable$state == currentState, ]$c_prop == 1)
COOPERATE else DEVIATE
action <-
if (qTable[qTable$state == currentState, ]$c_prop == 1)
COOPERATE else DEVIATE
action <-
if (qTable[qTable$state == currentState, ]$c_prop == 1)
COOPERATE else DEVIATE
qTable
currentState <<- state[sample(length(state),1)]
action <-
if (qTable[qTable$state == currentState, ]$c_prop == 1)
COOPERATE else DEVIATE
qTable
currentState <<- state[sample(length(state),1)]
action <-
if (qTable[qTable$state == currentState, ]$c_prop == 1)
COOPERATE else DEVIATE
# Q-Table initialization
# states
state <- c("C1", "D1", "C2", "D2", "C3", "D3")
# random initialization of propensities
c_prop <- c()
for (i in 1:length(state)) {
c_prop <- c(c_prop, as.integer(runif(1) > 0.5))
}
d_prop <- 1 - c_prop
# average payoffs
c_avPayoff <- c(rep(0,length(state)))
d_avPayoff <- c(rep(0,length(state)))
# optimal expected utility
oeu <- c(rep(0,length(state)))
# composition of Q-Table
qTable <<- data.frame(state, oeu,
c_prop, c_avPayoff,
d_prop, d_avPayoff)
View(qTable)
oeu <- c(rep(c(UTIL_MAX-coopCost, UTIL_MAX), 3))
UTIL_MAX <- 80
oeu <- c(rep(c(UTIL_MAX-coopCost, UTIL_MAX), 3))
coopCost <- 50
oeu <- c(rep(c(UTIL_MAX-coopCost, UTIL_MAX), 3))
# Q-Table initialization
# states
state <- c("C1", "D1", "C2", "D2", "C3", "D3")
# random initialization of propensities
c_prop <- c()
for (i in 1:length(state)) {
c_prop <- c(c_prop, as.integer(runif(1) > 0.5))
}
d_prop <- 1 - c_prop
# average payoffs
c_avPayoff <- c(rep(0,length(state)))
d_avPayoff <- c(rep(0,length(state)))
# optimal expected utility
oeu <- c(rep(c(UTIL_MAX-coopCost, UTIL_MAX), 3))
# composition of Q-Table
qTable <<- data.frame(state, oeu,
c_prop, c_avPayoff,
d_prop, d_avPayoff)
View(qTable)
1 % 10
1 %% 10
3 %% 10
30 %% 10
ASSESSMENT_INTERVAL <<- 10  # after how many rounds is the Q-Table being assessed
for (round in 1:100) {
if (round %% ASSESSMENT_INTERVAL == 0) {
print(round)
}
}
# Q-Table initialization
# states
state <- c("C1", "D1", "C2", "D2", "C3", "D3")
# random initialization of propensities
c_prop <- c()
for (i in 1:length(state)) {
c_prop <- c(c_prop, as.integer(runif(1) > 0.5))
}
d_prop <- 1 - c_prop
# payoffs
payoff <- c(rep(0,length(state)))
avPayoff <- c(rep(0,length(state)))
# optimal expected utility
oeu <- c(rep(c(UTIL_MAX-coopCost, UTIL_MAX), 3))
# composition of Q-Table
qTable <<- data.frame(state, oeu, c_prop, d_prop,
payoff, avPayoff)
View(qTable)
# Q-Table initialization
# states
state <- c("C1", "D1", "C2", "D2", "C3", "D3")
# random initialization of propensities
c_prop <- c()
for (i in 1:length(state)) {
c_prop <- c(c_prop, as.integer(runif(1) > 0.5))
}
d_prop <- 1 - c_prop
# payoffs
payoff <- c(rep(0,length(state)))
avPayoff <- c(rep(0,length(state)))
# optimal expected utility
oeu <- c(rep(c(UTIL_MAX-coopCost, UTIL_MAX), 3))
# composition of Q-Table
qTable <<- data.frame(state, oeu, payoff, avPayoff,
c_prop, d_prop)
View(qTable)
View(qTable)
# Q-Table initialization
# states
state <- c("C1", "D1", "C2", "D2", "C3", "D3")
# random initialization of propensities
c_prop <- c()
for (i in 1:length(state)) {
c_prop <- c(c_prop, as.integer(runif(1) > 0.5))
}
d_prop <- 1 - c_prop
# payoffs
payoff_per_ar <- c(rep(0,length(state)))
av_payoff_per_ar <- c(rep(0,length(state)))
# optimal expected utility
oeu <- c(rep(c(UTIL_MAX-coopCost, UTIL_MAX), 3))
# composition of Q-Table
qTable <<- data.frame(state, oeu, payoff_per_ar,
av_payoff_per_ar, c_prop, d_prop)
View(qTable)
ASSESSMENT_INTERVAL <<- 5         # after how many rounds is the Q-Table being assessed
ASP_C <<- UTIL_MAX - coopCost
ASP_D <<- UTIL_MAX
QL <<- 0.9                        # probability to switch actions, when aspiration level is not reached
# Q-Table initialization
# states
state <- c("C1", "D1", "C2", "D2", "C3", "D3")
# random initialization of propensities
c_prop <- c()
for (i in 1:length(state)) {
c_prop <- c(c_prop, as.integer(runif(1) > 0.5))
}
d_prop <- 1 - c_prop
# payoffs
payoff_per_ar <- c(rep(0,length(state)))
av_payoff_per_ar <- c(rep(0,length(state)))
# optimal expected utility
aspiration_level <- c(rep(c(ASP_C, ASP_D), 3))
# composition of Q-Table
qTable <<- data.frame(state, aspiration_level, payoff_per_ar,
av_payoff_per_ar, c_prop, d_prop)
View(qTable)
qTable[1,]
qTable[2,]
qTable[3,]
runif(1)
runif(1)
runif(1)
runif(1)
runif(1)
runif(1)
runif(1)
runif(1)
runif(1)
runif(1)
runif(1)
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
source('~/git/uu/mscp-model/code/simulation.R')
computeSimulation()
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
simData <- importVodSimData()
simData <- importVodSimData()[[1]]
View(simData)
source('~/git/uu/mscp-model/code/analysis.R')
simData <- importVodSimData()[[1]]
View(simData)
ID <- 1
allPlayersActions <- c(1,0,1)
ownAction <- allPlayersActions[ID]
N1 <- allPlayersActions[-c(ID)]
ID <- 2
allPlayersActions <- c(1,0,1)
ownAction <- allPlayersActions[ID]
N1 <- allPlayersActions[-c(ID)]
currentState <<- paste(ownAction, N1, sep = "")
currentState <<- paste(ownAction, as.character(N1), sep = "")
ownAction <- allPlayersActions[ID]
N1 <- allPlayersActions[-c(ID)]
currentState <<- paste(ownAction, as.character(N1), sep = "")
ownAction <- allPlayersActions[ID]
N1 <- allPlayersActions[-c(ID)]
currentState <<- paste(as.character(ownAction),
as.character(N1), sep = "")
ownAction <- allPlayersActions[ID]
N1 <- allPlayersActions[-c(ID)]
currentState <- paste(as.character(ownAction),
as.character(N1), sep = "")
ID <- 2
allPlayersActions <- c(1,0,1)
ownAction <- if (allPlayersActions[ID] == 1)
"C" else "D"
N1 <- allPlayersActions[-c(ID)]
currentState <<- paste(as.character(ownAction),
as.character(N1), sep = "")
currentState <<- paste(ownAction,
N1, sep = "")
ownAction <- if (allPlayersActions[ID] == 1)
"C" else "D"
N1 <- allPlayersActions[-c(ID)]
ownAction <- if (allPlayersActions[ID] == 1)
"C" else "D"
N1 <- sum(allPlayersActions[-c(ID)])
currentState <<- paste(ownAction,
N1, sep = "")
ID <- 2
ID <- 1
allPlayersActions <- c(1,0,1)
ownAction <- if (allPlayersActions[ID] == 1)
"C" else "D"
N1 <- sum(allPlayersActions[-c(ID)])
currentState <<- paste(ownAction,
N1, sep = "")
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
simData <- importVodSimData()[[1]]
View(simData)
source('~/git/uu/mscp-model/code/analysis.R')
simData <- importVodSimData()[[1]]
View(simData)
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
simData <- importVodSimData()[[1]]
View(simData)
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
simData <- importVodSimData()[[1]]
View(simData)
if (3 > 0 && 3 < 4) {
print("yes!")
}
if (0 > 0 && 3 < 4) {
print("yes!")
}
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
simData <- importVodSimData()[[1]]
View(simData)
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
ASP_C <<- 2*UTIL_MAX + (UTIL_MAX - coopCost)
coopCost <- 50
ASP_C <<- 2*UTIL_MAX + (UTIL_MAX - coopCost)
ASP_D <<- ASP_D
coopCost <- 50
ASP_C <<- 2*UTIL_MAX + (UTIL_MAX - coopCost)
ASP_D <<- ASP_C
state <- c("C0", "D0", "C1", "D1", "C2", "D2", "C3", "D3")
c_prop <- c()
for (i in 1:length(state)) {
c_prop <- c(c_prop, as.integer(runif(1) > 0.5))
}
d_prop <- 1 - c_prop
payoff_per_ar <- c(rep(0,length(state)))
av_payoff_per_ar <- c(rep(0,length(state)))
aspiration_level <- c(rep(c(ASP_C, ASP_D), length(state)/2))
qTable <<- data.frame(state, aspiration_level, payoff_per_ar,
av_payoff_per_ar, c_prop, d_prop)
View(qTable)
coopCost <- 50
# aspiration levels
ASP_C <<- (2*UTIL_MAX + (UTIL_MAX - coopCost)) / 3
ASP_D <<- ASP_C
# Q-Table initialization
# states
state <- c("C0", "D0", "C1", "D1", "C2", "D2", "C3", "D3")
# random initialization of propensities
c_prop <- c()
for (i in 1:length(state)) {
c_prop <- c(c_prop, as.integer(runif(1) > 0.5))
}
d_prop <- 1 - c_prop
# payoffs
payoff_per_ar <- c(rep(0,length(state)))
av_payoff_per_ar <- c(rep(0,length(state)))
# optimal expected utility
aspiration_level <- c(rep(c(ASP_C, ASP_D), length(state)/2))
# composition of Q-Table
qTable <<- data.frame(state, aspiration_level, payoff_per_ar,
av_payoff_per_ar, c_prop, d_prop)
View(qTable)
source('~/git/uu/mscp-model/code/players/playerWinStayLooseShift.R')
source('~/git/uu/mscp-model/code/composition.R')
View(qTable)
simulateAndAnalyze()
simData <- importVodSimData()[[1]]
View(simData)
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
simData <- importVodSimData()[[1]]
View(simData)
source('~/git/uu/mscp-model/code/composition.R')
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
source('~/git/uu/mscp-model/code/composition.R')
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
source('~/git/uu/mscp-model/code/composition.R')
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
source('~/git/uu/mscp-model/code/composition.R')
simulateAndAnalyze()
setwd("/Users/hendrik/git/uu/mscp-model/stata")
library(foreign)
mydata <- read.dta("vod2_lni.dta")
install.packages("readstata13")
setwd("/Users/hendrik/git/uu/mscp-model/stata")
library(readstata13)
mydata <- read.dta13("vod2_lni.dta")
View(mydata)
